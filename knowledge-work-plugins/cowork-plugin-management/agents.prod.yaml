version: v1
kind: ServiceTemplate
variables: []

metadata:
  name: claude-cowork-plugin-management
  description: An agent that uses Anthropic's cowork plugin management knowledge work plugin
  annotations:
    meshagent.service.id: meshagent.claude-cowork-plugin-management

agents:
  - name: claude-cowork-plugin-management
    annotations:
      meshagent.agent.type: ChatBot

container:
  image: us-central1-docker.pkg.dev/meshagent-public/images/cli:{SERVER_VERSION}-esgz
  command: /bin/bash /var/start.sh
  storage:
    room:
    - path: /data
      read_only: false
    files:
    - path: /var/start.sh
      text: |
          #!/bin/bash

          set -e

          mkdir -p /data/knowledge-work-plugins
          mkdir -p /data/agents/claude-cowork-plugin-management
          if [ -d /knowledge-work-plugins ]; then
            cp -R -n /knowledge-work-plugins/* /data/knowledge-work-plugins/ 2>/dev/null || true
          fi
          if [[ ! -f /data/agents/claude-cowork-plugin-management/rules.txt ]]; then
            cp /var/rules-claude-cowork-plugin-management.txt /data/agents/claude-cowork-plugin-management/rules.txt
          fi

          exec /usr/bin/meshagent chatbot join \
            --require-storage \
            --require-web-search \
            --require-web-fetch \
            --storage-tool-local-path=/knowledge-work-plugins:/knowledge-work-plugins \
            --storage-tool-room-path=/:/data \
            --script-tool \
            -rr=agents/claude-cowork-plugin-management/rules.txt \
            --skill-dir /data/knowledge-work-plugins/skills/cowork-plugin-customizer \
            --skill-dir /data/knowledge-work-plugins/skills/create-cowork-plugin \
    - path: /var/rules-claude-cowork-plugin-management.txt
      read_only: true
      text: |
          ONLY use the knowledge-work-plugins skills to answer questions and follow the pattern specified in the skill
          you can use the storage tool to read skills not just the shell tool
          when a question could be served by a skill, read the skill and follow the pattern specified in the skill
          when using the storage tool to read files attached or referenced by the user, in the room, or output by the shell tool, the file path should be prefixed with /data.
          when using the storage tool to read skills, the path should be prefixed with /data/knowledge-work-plugins (the folder where the plugins are located)
          You have customizable rules stored in agents/claude-cowork-plugin-management/rules.txt, you can use the read_file tool to read your rules. You can use the write_file tool to update the contents of the rules file or other text files. Use the read_file tool to read PDFs, examine images, or read files with a text/* mime type from attachments or files.
          You are a MeshAgent agent. MeshAgent is an agent operating system. You can find out more at www.meshagent.com and docs.meshagent.com
          You have some slash commands available
    - path: /knowledge-work-plugins/skills/cowork-plugin-customizer/LICENSE.txt
      text: |

             Apache License
                                     Version 2.0, January 2004
                                  http://www.apache.org/licenses/

             TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

             1. Definitions.

                "License" shall mean the terms and conditions for use, reproduction,
                and distribution as defined by Sections 1 through 9 of this document.

                "Licensor" shall mean the copyright owner or entity authorized by
                the copyright owner that is granting the License.

                "Legal Entity" shall mean the union of the acting entity and all
                other entities that control, are controlled by, or are under common
                control with that entity. For the purposes of this definition,
                "control" means (i) the power, direct or indirect, to cause the
                direction or management of such entity, whether by contract or
                otherwise, or (ii) ownership of fifty percent (50%) or more of the
                outstanding shares, or (iii) beneficial ownership of such entity.

                "You" (or "Your") shall mean an individual or Legal Entity
                exercising permissions granted by this License.

                "Source" form shall mean the preferred form for making modifications,
                including but not limited to software source code, documentation
                source, and configuration files.

                "Object" form shall mean any form resulting from mechanical
                transformation or translation of a Source form, including but
                not limited to compiled object code, generated documentation,
                and conversions to other media types.

                "Work" shall mean the work of authorship, whether in Source or
                Object form, made available under the License, as indicated by a
                copyright notice that is included in or attached to the work
                (an example is provided in the Appendix below).

                "Derivative Works" shall mean any work, whether in Source or Object
                form, that is based on (or derived from) the Work and for which the
                editorial revisions, annotations, elaborations, or other modifications
                represent, as a whole, an original work of authorship. For the purposes
                of this License, Derivative Works shall not include works that remain
                separable from, or merely link (or bind by name) to the interfaces of,
                the Work and Derivative Works thereof.

                "Contribution" shall mean any work of authorship, including
                the original version of the Work and any modifications or additions
                to that Work or Derivative Works thereof, that is intentionally
                submitted to Licensor for inclusion in the Work by the copyright owner
                or by an individual or Legal Entity authorized to submit on behalf of
                the copyright owner. For the purposes of this definition, "submitted"
                means any form of electronic, verbal, or written communication sent
                to the Licensor or its representatives, including but not limited to
                communication on electronic mailing lists, source code control systems,
                and issue tracking systems that are managed by, or on behalf of, the
                Licensor for the purpose of discussing and improving the Work, but
                excluding communication that is conspicuously marked or otherwise
                designated in writing by the copyright owner as "Not a Contribution."

                "Contributor" shall mean Licensor and any individual or Legal Entity
                on behalf of whom a Contribution has been received by Licensor and
                subsequently incorporated within the Work.

             2. Grant of Copyright License. Subject to the terms and conditions of
                this License, each Contributor hereby grants to You a perpetual,
                worldwide, non-exclusive, no-charge, royalty-free, irrevocable
                copyright license to reproduce, prepare Derivative Works of,
                publicly display, publicly perform, sublicense, and distribute the
                Work and such Derivative Works in Source or Object form.

             3. Grant of Patent License. Subject to the terms and conditions of
                this License, each Contributor hereby grants to You a perpetual,
                worldwide, non-exclusive, no-charge, royalty-free, irrevocable
                (except as stated in this section) patent license to make, have made,
                use, offer to sell, sell, import, and otherwise transfer the Work,
                where such license applies only to those patent claims licensable
                by such Contributor that are necessarily infringed by their
                Contribution(s) alone or by combination of their Contribution(s)
                with the Work to which such Contribution(s) was submitted. If You
                institute patent litigation against any entity (including a
                cross-claim or counterclaim in a lawsuit) alleging that the Work
                or a Contribution incorporated within the Work constitutes direct
                or contributory patent infringement, then any patent licenses
                granted to You under this License for that Work shall terminate
                as of the date such litigation is filed.

             4. Redistribution. You may reproduce and distribute copies of the
                Work or Derivative Works thereof in any medium, with or without
                modifications, and in Source or Object form, provided that You
                meet the following conditions:

                (a) You must give any other recipients of the Work or
                    Derivative Works a copy of this License; and

                (b) You must cause any modified files to carry prominent notices
                    stating that You changed the files; and

                (c) You must retain, in the Source form of any Derivative Works
                    that You distribute, all copyright, patent, trademark, and
                    attribution notices from the Source form of the Work,
                    excluding those notices that do not pertain to any part of
                    the Derivative Works; and

                (d) If the Work includes a "NOTICE" text file as part of its
                    distribution, then any Derivative Works that You distribute must
                    include a readable copy of the attribution notices contained
                    within such NOTICE file, excluding those notices that do not
                    pertain to any part of the Derivative Works, in at least one
                    of the following places: within a NOTICE text file distributed
                    as part of the Derivative Works; within the Source form or
                    documentation, if provided along with the Derivative Works; or,
                    within a display generated by the Derivative Works, if and
                    wherever such third-party notices normally appear. The contents
                    of the NOTICE file are for informational purposes only and
                    do not modify the License. You may add Your own attribution
                    notices within Derivative Works that You distribute, alongside
                    or as an addendum to the NOTICE text from the Work, provided
                    that such additional attribution notices cannot be construed
                    as modifying the License.

                You may add Your own copyright statement to Your modifications and
                may provide additional or different license terms and conditions
                for use, reproduction, or distribution of Your modifications, or
                for any such Derivative Works as a whole, provided Your use,
                reproduction, and distribution of the Work otherwise complies with
                the conditions stated in this License.

             5. Submission of Contributions. Unless You explicitly state otherwise,
                any Contribution intentionally submitted for inclusion in the Work
                by You to the Licensor shall be under the terms and conditions of
                this License, without any additional terms or conditions.
                Notwithstanding the above, nothing herein shall supersede or modify
                the terms of any separate license agreement you may have executed
                with Licensor regarding such Contributions.

             6. Trademarks. This License does not grant permission to use the trade
                names, trademarks, service marks, or product names of the Licensor,
                except as required for reasonable and customary use in describing the
                origin of the Work and reproducing the content of the NOTICE file.

             7. Disclaimer of Warranty. Unless required by applicable law or
                agreed to in writing, Licensor provides the Work (and each
                Contributor provides its Contributions) on an "AS IS" BASIS,
                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
                implied, including, without limitation, any warranties or conditions
                of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
                PARTICULAR PURPOSE. You are solely responsible for determining the
                appropriateness of using or redistributing the Work and assume any
                risks associated with Your exercise of permissions under this License.

             8. Limitation of Liability. In no event and under no legal theory,
                whether in tort (including negligence), contract, or otherwise,
                unless required by applicable law (such as deliberate and grossly
                negligent acts) or agreed to in writing, shall any Contributor be
                liable to You for damages, including any direct, indirect, special,
                incidental, or consequential damages of any character arising as a
                result of this License or out of the use or inability to use the
                Work (including but not limited to damages for loss of goodwill,
                work stoppage, computer failure or malfunction, or any and all
                other commercial damages or losses), even if such Contributor
                has been advised of the possibility of such damages.

             9. Accepting Warranty or Additional Liability. While redistributing
                the Work or Derivative Works thereof, You may choose to offer,
                and charge a fee for, acceptance of support, warranty, indemnity,
                or other liability obligations and/or rights consistent with this
                License. However, in accepting such obligations, You may act only
                on Your own behalf and on Your sole responsibility, not on behalf
                of any other Contributor, and only if You agree to indemnify,
                defend, and hold each Contributor harmless for any liability
                incurred by, or claims asserted against, such Contributor by reason
                of your accepting any such warranty or additional liability.

             END OF TERMS AND CONDITIONS

             APPENDIX: How to apply the Apache License to your work.

                To apply the Apache License to your work, attach the following
                boilerplate notice, with the fields enclosed by brackets "[]"
                replaced with your own identifying information. (Don't include
                the brackets!)  The text should be enclosed in the appropriate
                comment syntax for the file format. We also recommend that a
                file or class name and description of purpose be included on the
                same "printed page" as the copyright notice for easier
                identification within third-party archives.

             Copyright [yyyy] [name of copyright owner]

             Licensed under the Apache License, Version 2.0 (the "License");
             you may not use this file except in compliance with the License.
             You may obtain a copy of the License at

                 http://www.apache.org/licenses/LICENSE-2.0

             Unless required by applicable law or agreed to in writing, software
             distributed under the License is distributed on an "AS IS" BASIS,
             WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             See the License for the specific language governing permissions and
             limitations under the License.
    - path: /knowledge-work-plugins/skills/cowork-plugin-customizer/SKILL.md
      text: |
          ---
          name: cowork-plugin-customizer
          description: >
            Customize or personalize a Claude Code plugin for a specific organization's tools and workflows.
            Use when users want to customize a plugin, replace tool placeholders, or configure MCP servers for a plugin.
            This skill requires Cowork mode with mounted plugin directories and will not work in remote or standard CLI sessions.
          compatibility: Requires Cowork desktop app environment with access to mounted plugin directories (mnt/.local-plugins, mnt/.plugins).
          ---

          # Cowork Plugin Customization

          Adapt a generic plugin template to a specific organization by replacing customization points with actual tool names, configuring MCP servers, and applying organization-specific customizations.

          > **Finding the plugin**: To find the plugin's source files, run `find mnt/.local-plugins mnt/.plugins -type d -name "*<plugin-name>*"` to locate the plugin directory, then read its files to understand its structure before making changes. If you cannot find the plugin directory, the user is likely running this conversation in a remote container. Abort and let them know: "Customizing plugins is currently only available in the desktop app's Cowork mode."

          ## Overview

          Generic plugins mark customization points with a `~~` prefix. Any line or value starting with `~~` is a placeholder that should be replaced during customization (e.g., `~~Jira` → `Asana`, `~~your-team-channel` → `#engineering`). To find all customization points in a plugin, use:

          ```bash
          grep -rn '~~\w' /path/to/plugin --include='*.md' --include='*.json'
          ```

          > **Important**: Never change the name of the plugin or skill being customized. Only replace `~~`-prefixed placeholder values and update content — do not rename directories, files, or the plugin/skill name fields.

          > **Nontechnical output**: All user-facing output (todo list items, questions, summaries) must be written in plain, nontechnical language. Never mention `~~` prefixes, placeholders, or customization points to the user. Frame everything in terms of learning about the organization and its tools.

          The process:
          1. **Gather context** — use knowledge MCPs to learn what tools and processes the organization uses
          2. **Create todo list** — grep for `~~\w` to find all customization points and build a todo list
          3. **Complete todo items** — apply gathered context, falling back to user questions when unclear
          4. **Search for useful MCPs** — find and connect MCPs for identified tools

          If an answer cannot be found via knowledge MCPs or user input, leave the customization point unchanged for a future customization cycle.

          ## Customization Workflow

          ### Phase 1: Gather Context from Knowledge MCPs

          Use company-internal knowledge MCPs to collect information. See `references/search-strategies.md` for detailed query patterns by category.

          **What to gather:**
          - Tool names for each `~~`-prefixed placeholder
          - Organizational processes and workflows
          - Team conventions (naming, statuses, estimation scales)
          - Configuration values (workspace IDs, project names, team identifiers)

          **Sources to search:**
          1. **Chat/Slack MCPs** — tool mentions, integrations, workflow discussions
          2. **Document MCPs** — onboarding docs, tool guides, setup instructions
          3. **Email MCPs** — license notifications, admin emails, setup invitations

          Record all findings for use in Phase 3.

          ### Phase 2: Create Todo List from Customization Points

          Run `grep -rn '~~\w' /path/to/plugin --include='*.md' --include='*.json'` to find all customization points. Group them by theme and create a todo list with user-friendly descriptions that focus on learning about the organization:

          - **Good**: "Learn how standup prep works at Company"
          - **Bad**: "Replace placeholders in commands/standup-prep.md"

          ### Phase 3: Complete Todo Items

          Work through each item using Phase 1 context.

          **If knowledge MCPs provided a clear answer**: Apply directly without confirmation.

          **Otherwise**: Use AskUserQuestion. Don't assume "industry standard" defaults are correct — if knowledge MCPs didn't provide a specific answer, ask. Note: AskUserQuestion always includes a Skip button and a free-text input box for custom answers, so do not include `None` or `Other` as options.

          **Types of changes:**

          1. **Customization point replacements**: `~~Jira` → `Asana`, `~~your-org-channel` → `#engineering`
          2. **URL pattern updates**: `tickets.example.com/your-team/123` → `app.asana.com/0/PROJECT_ID/TASK_ID`
          3. **Organization-specific values**: Workspace IDs, project names, team identifiers

          If user doesn't know or skips, leave the `~~`-prefixed value unchanged.

          ### Phase 4: Search for Useful MCPs

          After all customization points have been resolved, connect MCPs for the tools that were identified. See `references/mcp-servers.md` for the full workflow, category-to-keywords mapping, and config file format.

          For each tool identified during customization:
          1. Search the registry: `search_mcp_registry(keywords=[...])` using category keywords from `references/mcp-servers.md`, or search for the specific tool name if already known
          2. If unconnected: `suggest_connectors(directoryUuids=["chosen-uuid"])` — user completes OAuth
          3. Update the plugin's MCP config file (check `plugin.json` for custom location, otherwise `.mcp.json` at root)

          Collect all MCP results and present them together in the summary output (see below) — don't present MCPs one at a time during this phase.

          **Note:** First-party integrations (Gmail, Google Calendar, Google Drive) are connected at the user level and don't need plugin `.mcp.json` entries.

          ## Packaging the Plugin

          After all customizations are applied, package the plugin as a `.plugin` file for the user:

          1. **Zip the plugin directory** (excluding `setup/` since it's no longer needed):
             ```bash
             cd /path/to/plugin && zip -r /tmp/plugin-name.plugin . -x "setup/*" && cp /tmp/plugin-name.plugin /path/to/outputs/plugin-name.plugin
             ```
          2. **Present the file to the user** with the `.plugin` extension so they can install it directly. (Presenting the .plugin file will show to the user as a rich preview where they can look through the plugin files, and they can accept the customization by pressing a button.)

          > **Important**: Always create the zip in `/tmp/` first, then copy to the outputs folder. Writing directly to the outputs folder may fail due to permissions and leave behind temporary files.

          > **Naming**: Use the original plugin directory name for the `.plugin` file (e.g., if the plugin directory is `coder`, the output file should be `coder.plugin`). Do not rename the plugin or its files during customization — only replace placeholder values and update content.

          ## Summary Output

          After customization, present the user with a summary of what was learned grouped by source. Always include the MCPs sections showing which MCPs were connected during setup and which ones the user should still connect:

          ```markdown
          ## From searching Slack
          - You use Asana for project management
          - Sprint cycles are 2 weeks

          ## From searching documents
          - Story points use T-shirt sizes

          ## From your answers
          - Ticket statuses are: Backlog, In Progress, In Review, Done
          ```

          Then present the MCPs that were connected during setup and any that the user should still connect, with instructions on how to connect them.

          If no knowledge MCPs were available in Phase 1, and the user had to answer at least one question manually, include a note at the end:
          > By the way, connecting sources like Slack or Microsoft Teams would let me find answers automatically next time you customize a plugin.

          ## Additional Resources

          - **`references/mcp-servers.md`** — MCP discovery workflow, category-to-keywords mapping, config file locations
          - **`references/search-strategies.md`** — Knowledge MCP query patterns for finding tool names and org values
          - **`examples/customized-mcp.json`** — Example fully configured `.mcp.json`
    - path: /knowledge-work-plugins/skills/cowork-plugin-customizer/examples/customized-mcp.json
      text: |
          {
            "mcpServers": {
              "github": {
                "type": "http",
                "url": "https://api.githubcopilot.com/mcp/",
                "headers": {
                  "Authorization": "Bearer ${GITHUB_TOKEN}"
                }
              },
              "asana": {
                "type": "sse",
                "url": "https://mcp.asana.com/sse"
              },
              "slack": {
                "type": "http",
                "url": "https://slack.mcp.claude.com/mcp"
              },
              "figma": {
                "type": "http",
                "url": "https://mcp.figma.com/mcp"
              },
              "datadog": {
                "type": "http",
                "url": "https://api.datadoghq.com/mcp",
                "headers": {
                  "DD-API-KEY": "${DATADOG_API_KEY}",
                  "DD-APPLICATION-KEY": "${DATADOG_APP_KEY}"
                }
              }
            },
            "recommendedCategories": [
              "source-control",
              "project-management",
              "chat",
              "documents",
              "wiki-knowledge-base",
              "design-graphics",
              "analytics-bi"
            ]
          }
    - path: /knowledge-work-plugins/skills/cowork-plugin-customizer/references/mcp-servers.md
      text: |
          # MCP Discovery and Connection

          How to find and connect MCPs during plugin customization.

          ## Available Tools

          ### `search_mcp_registry`
          Search the MCP directory for available connectors.

          **Input:** `{ "keywords": ["array", "of", "search", "terms"] }`

          **Output:** Up to 10 results, each with:
          - `name`: MCP display name
          - `description`: One-liner description
          - `tools`: List of tool names the MCP provides
          - `url`: MCP endpoint URL (use this in `.mcp.json`)
          - `directoryUuid`: UUID for use with suggest_connectors
          - `connected`: Boolean - whether user has this MCP connected

          ### `suggest_connectors`
          Display Connect buttons to let users install/connect MCPs.

          **Input:** `{ "directoryUuids": ["uuid1", "uuid2"] }`

          **Output:** Renders UI with Connect buttons for each MCP

          ## Category-to-Keywords Mapping

          | Category | Search Keywords |
          |----------|-----------------|
          | `project-management` | `["asana", "jira", "linear", "monday", "tasks"]` |
          | `software-coding` | `["github", "gitlab", "bitbucket", "code"]` |
          | `chat` | `["slack", "teams", "discord"]` |
          | `documents` | `["google docs", "notion", "confluence"]` |
          | `calendar` | `["google calendar", "calendar"]` |
          | `email` | `["gmail", "outlook", "email"]` |
          | `design-graphics` | `["figma", "sketch", "design"]` |
          | `analytics-bi` | `["datadog", "grafana", "analytics"]` |
          | `crm` | `["salesforce", "hubspot", "crm"]` |
          | `wiki-knowledge-base` | `["notion", "confluence", "outline", "wiki"]` |
          | `data-warehouse` | `["bigquery", "snowflake", "redshift"]` |
          | `conversation-intelligence` | `["gong", "chorus", "call recording"]` |

          ## Workflow

          1. **Find customization point**: Look for `~~`-prefixed values (e.g., `~~Jira`)
          2. **Check earlier phase findings**: Did you already learn which tool they use?
             - **Yes**: Search for that specific tool to get its `url`, skip to step 5
             - **No**: Continue to step 3
          3. **Search**: Call `search_mcp_registry` with mapped keywords
          4. **Present choices and ask user**: Show all results, ask which they use
          5. **Connect if needed**: If not connected, call `suggest_connectors`
          6. **Update MCP config**: Add config using the `url` from search results

          ## Updating Plugin MCP Configuration

          ### Finding the Config File

          1. **Check `plugin.json`** for an `mcpServers` field:
             ```json
             {
               "name": "my-plugin",
               "mcpServers": "./config/servers.json"
             }
             ```
             If present, edit the file at that path.

          2. **If no `mcpServers` field**, use `.mcp.json` at the plugin root (default).

          3. **If `mcpServers` points only to `.mcpb` files** (bundled servers), create a new `.mcp.json` at the plugin root.

          ### Config File Format

          Both wrapped and unwrapped formats are supported:

          ```json
          {
            "mcpServers": {
              "github": {
                "type": "http",
                "url": "https://api.githubcopilot.com/mcp/"
              }
            }
          }
          ```

          Use the `url` field from `search_mcp_registry` results.

          **Note:** First-party integrations (Gmail, Google Calendar, Google Drive) are connected at the user level and don't need plugin `.mcp.json` entries.
    - path: /knowledge-work-plugins/skills/cowork-plugin-customizer/references/search-strategies.md
      text: |
          # Knowledge MCP Search Strategies

          Query patterns for gathering organizational context during plugin customization.

          ## Finding Tool Names

          **Source control:**
          - Search: "GitHub" OR "GitLab" OR "Bitbucket"
          - Search: "pull request" OR "merge request"
          - Look for: repository links, CI/CD mentions

          **Project management:**
          - Search: "Asana" OR "Jira" OR "Linear" OR "Monday"
          - Search: "sprint" AND "tickets"
          - Look for: task links, project board mentions

          **Chat:**
          - Search: "Slack" OR "Teams" OR "Discord"
          - Look for: channel mentions, integration discussions

          **Analytics:**
          - Search: "Datadog" OR "Grafana" OR "Mixpanel"
          - Search: "monitoring" OR "observability"
          - Look for: dashboard links, alert configurations

          **Design:**
          - Search: "Figma" OR "Sketch" OR "Adobe XD"
          - Look for: design file links, handoff discussions

          **CRM:**
          - Search: "Salesforce" OR "HubSpot"
          - Look for: deal mentions, customer record links

          ## Finding Organization Values

          **Workspace/project IDs:**
          - Search for existing integrations or bookmarked links
          - Look for admin/setup documentation

          **Team conventions:**
          - Search: "story points" OR "estimation"
          - Search: "workflow" OR "ticket status"
          - Look for engineering process docs

          **Channel/team names:**
          - Search: "standup" OR "engineering" OR "releases"
          - Look for channel naming patterns

          ## When Knowledge MCPs Are Unavailable

          If no knowledge MCPs are configured, skip automatic discovery and proceed directly to AskUserQuestion for all categories. Note: AskUserQuestion always includes a Skip button and a free-text input box for custom answers, so do not include `None` or `Other` as options.
    - path: /knowledge-work-plugins/skills/create-cowork-plugin/SKILL.md
      text: |
          ---
          name: create-cowork-plugin
          description: >
            Guide users through creating a new plugin from scratch in a cowork session.
            Use when users want to create a plugin, build a plugin, make a new plugin, develop a plugin, scaffold a plugin, start a plugin from scratch, or design a plugin.
            This skill requires Cowork mode with access to the outputs directory for delivering the final .plugin file.
          compatibility: Requires Cowork desktop app environment with access to the outputs directory for delivering .plugin files.
          ---

          # Create Cowork Plugin

          Build a new plugin from scratch through guided conversation. Walk the user through discovery, planning, design, implementation, and packaging — delivering a ready-to-install `.plugin` file at the end.

          ## Overview

          A plugin is a self-contained directory that extends Claude's capabilities with commands, skills, agents, hooks, and MCP server integrations. This skill encodes the full plugin architecture and a five-phase workflow for creating one conversationally.

          The process:
          1. **Discovery** — understand what the user wants to build
          2. **Component Planning** — determine which component types are needed
          3. **Design & Clarifying Questions** — specify each component in detail
          4. **Implementation** — create all plugin files
          5. **Review & Package** — deliver the `.plugin` file

          > **Nontechnical output**: Keep all user-facing conversation in plain language. Do not expose implementation details like file paths, directory structures, or schema fields unless the user asks. Frame everything in terms of what the plugin will do.

          ## Plugin Architecture

          ### Directory Structure

          Every plugin follows this layout:

          ```
          plugin-name/
          ├── .claude-plugin/
          │   └── plugin.json           # Required: plugin manifest
          ├── commands/                 # Slash commands (.md files)
          ├── agents/                   # Subagent definitions (.md files)
          ├── skills/                   # Skills (subdirectories with SKILL.md)
          │   └── skill-name/
          │       ├── SKILL.md
          │       └── references/
          ├── .mcp.json                 # MCP server definitions
          └── README.md                 # Plugin documentation
          ```


          **Rules:**
          - `.claude-plugin/plugin.json` is always required
          - Component directories (`commands/`, `agents/`, `skills/`) go at the plugin root, not inside `.claude-plugin/`
          - Only create directories for components the plugin actually uses
          - Use kebab-case for all directory and file names

          ### plugin.json Manifest

          Located at `.claude-plugin/plugin.json`. Minimal required field is `name`.

          ```json
          {
            "name": "plugin-name",
            "version": "0.1.0",
            "description": "Brief explanation of plugin purpose",
            "author": {
              "name": "Author Name"
            }
          }
          ```

          **Name rules:** kebab-case, lowercase with hyphens, no spaces or special characters.
          **Version:** semver format (MAJOR.MINOR.PATCH). Start at `0.1.0`.

          Optional fields: `homepage`, `repository`, `license`, `keywords`.

          Custom component paths can be specified (supplements, does not replace, auto-discovery):
          ```json
          {
            "commands": "./custom-commands",
            "agents": ["./agents", "./specialized-agents"],
            "hooks": "./config/hooks.json",
            "mcpServers": "./.mcp.json"
          }
          ```

          ### Component Schemas

          Detailed schemas for each component type are in `references/component-schemas.md`. Summary:

          | Component | Location | Format |
          |-----------|----------|--------|
          | Commands | `commands/*.md` | Markdown + YAML frontmatter |
          | Skills | `skills/*/SKILL.md` | Markdown + YAML frontmatter |
          | MCP Servers | `.mcp.json` | JSON |
          | Agents (uncommonly used in Cowork) | `agents/*.md` | Markdown + YAML frontmatter |
          | Hooks (rarely used in Cowork) | `hooks/hooks.json` | JSON |

          This schema is shared with Claude Code's plugin system, but you're creating a plugin for Claude Cowork, a desktop app for doing knowledge work.
          Cowork users will usually find commands and skills the most useful.

          ### Customizable plugins with `~~` placeholders

          > **Do not use or ask about this pattern by default.** Only introduce `~~` placeholders if the user explicitly says they want people outside their organization to use the plugin.
          > You can mention this is an option if it seems like the user wants to distribute the plugin externally, but do not proactively ask about this with AskUserQuestion.

          When a plugin is intended to be shared with others outside their company, it might have parts that need to be adapted to individual users.
          You might need to reference external tools by category rather than specific product (e.g., "project tracker" instead of "Jira").
          When sharing is needed, use generic language and mark these as requiring customization with two tilde characters such as `create an issue in ~~project tracker`.
          If used any tool categories, write a `CONNECTORS.md` file at the plugin root to explain:

          ```markdown
          # Connectors

          ## How tool references work

          Plugin files use `~~category` as a placeholder for whatever tool the user
          connects in that category. Plugins are tool-agnostic — they describe
          workflows in terms of categories rather than specific products.

          ## Connectors for this plugin

          | Category | Placeholder | Options |
          |----------|-------------|-----------------|---------------|
          | Chat | `~~chat` | Slack, Microsoft Teams, Discord |
          | Project tracker | `~~project tracker` | Linear, Asana, Jira |
          ```

          ### ${CLAUDE_PLUGIN_ROOT} Variable

          Use `${CLAUDE_PLUGIN_ROOT}` for all intra-plugin path references in hooks and MCP configs. Never hardcode absolute paths.

          ## Guided Workflow

          When you ask the user something, use AskUserQuestion. Don't assume "industry standard" defaults are correct. Note: AskUserQuestion always includes a Skip button and a free-text input box for custom answers, so do not include `None` or `Other` as options.

          ### Phase 1: Discovery

          **Goal**: Understand what the user wants to build and why.

          Ask (only what is unclear — skip questions if the user's initial request already answers them):

          - What should this plugin do? What problem does it solve?
          - Who will use it and in what context?
          - Does it integrate with any external tools or services?
          - Is there a similar plugin or workflow to reference?

          Summarize understanding and confirm before proceeding.

          **Output**: Clear statement of plugin purpose and scope.

          ### Phase 2: Component Planning

          **Goal**: Determine which component types the plugin needs.

          Based on the discovery answers, determine:

          - **Skills** — Does it need specialized knowledge that Claude should load on-demand? (domain expertise, reference schemas, workflow guides)
          - **Commands** — Are there user-initiated actions? (deploy, configure, analyze, review)
          - **MCP Servers** — Does it need external service integration? (databases, APIs, SaaS tools)
          - **Agents (uncommon)** — Are there autonomous multi-step tasks? (validation, generation, analysis)
          - **Hooks (rare)** — Should something happen automatically on certain events? (enforce policies, load context, validate operations)

          Present a component plan table, including component types you decided not to create:

          ```
          | Component | Count | Purpose |
          |-----------|-------|---------|
          | Skills    | 1     | Domain knowledge for X |
          | Commands  | 2     | /do-thing, /check-thing |
          | Agents    | 0     | Not needed |
          | Hooks     | 1     | Validate writes |
          | MCP       | 1     | Connect to service Y |
          ```

          Get user confirmation or adjustments before proceeding.

          **Output**: Confirmed list of components to create.

          ### Phase 3: Design & Clarifying Questions

          **Goal**: Specify each component in detail. Resolve all ambiguities before implementation.

          For each component type in the plan, ask targeted design questions. Present questions grouped by component type. Wait for answers before proceeding.

          **Skills:**
          - What user queries should trigger this skill?
          - What knowledge domains does it cover?
          - Should it include reference files for detailed content?

          **Commands:**
          - What arguments does each command accept?
          - What tools does each command need? (Read, Write, Bash, Grep, etc.)
          - Is each command interactive or automated?

          **Agents:**
          - Should each agent trigger proactively or only when requested?
          - What tools does it need?
          - What should the output format be?

          **Hooks:**
          - Which events? (PreToolUse, PostToolUse, Stop, SessionStart, etc.)
          - What behavior — validate, block, modify, add context?
          - Prompt-based (LLM-driven) or command-based (deterministic script)?

          **MCP Servers:**
          - What server type? (stdio for local, SSE for hosted with OAuth, HTTP for REST APIs)
          - What authentication method?
          - What tools should be exposed?

          If the user says "whatever you think is best," provide specific recommendations and get explicit confirmation.

          **Output**: Detailed specification for every component.

          ### Phase 4: Implementation

          **Goal**: Create all plugin files following best practices.

          **Order of operations:**
          1. Create the plugin directory structure
          2. Create `plugin.json` manifest
          3. Create each component (see `references/component-schemas.md` for exact formats)
          4. Create `README.md` documenting the plugin

          **Implementation guidelines:**

          - **Commands** are instructions FOR Claude, not messages to the user. Write them as directives about what to do.
          - **Skills** use progressive disclosure: lean SKILL.md body (under 3,000 words), detailed content in `references/`. Frontmatter description must be third-person with specific trigger phrases.
          - **Agents** need a description with `<example>` blocks showing triggering conditions, plus a system prompt in the markdown body.
          - **Hooks** config goes in `hooks/hooks.json`. Use `${CLAUDE_PLUGIN_ROOT}` for script paths. Prefer prompt-based hooks for complex logic.
          - **MCP configs** go in `.mcp.json` at plugin root. Use `${CLAUDE_PLUGIN_ROOT}` for local server paths. Document required env vars in README.

          ### Phase 5: Review & Package

          **Goal**: Deliver the finished plugin.

          1. Summarize what was created — list each component and its purpose
          2. Ask if the user wants any adjustments
          3. Run `claude plugin validate <path-to-plugin-json>`; fix any errors and warnings
          4. Package as a `.plugin` file:

          ```bash
          cd /path/to/plugin-dir && zip -r /tmp/plugin-name.plugin . -x "*.DS_Store" && cp /tmp/plugin-name.plugin /path/to/outputs/plugin-name.plugin
          ```

          > **Important**: Always create the zip in `/tmp/` first, then copy to the outputs folder. Writing directly to the outputs folder may fail due to permissions.

          > **Naming**: Use the plugin name from `plugin.json` for the `.plugin` file (e.g., if name is `code-reviewer`, output `code-reviewer.plugin`).

          The `.plugin` file will appear in the chat as a rich preview where the user can browse the files and accept the plugin by pressing a button.

          ## Best Practices

          - **Start small**: Begin with the minimum viable set of components. A plugin with one well-crafted skill is more useful than one with five half-baked components.
          - **Progressive disclosure for skills**: Core knowledge in SKILL.md, detailed reference material in `references/`, working examples in `examples/`.
          - **Clear trigger phrases**: Skill descriptions should include specific phrases users would say. Agent descriptions should include `<example>` blocks.
          - **Commands are for Claude**: Write command content as instructions for Claude to follow, not documentation for the user to read.
          - **Imperative writing style**: Use verb-first instructions in skills ("Parse the config file," not "You should parse the config file").
          - **Portability**: Always use `${CLAUDE_PLUGIN_ROOT}` for intra-plugin paths, never hardcoded paths.
          - **Security**: Use environment variables for credentials, HTTPS for remote servers, least-privilege tool access.

          ## Additional Resources

          - **`references/component-schemas.md`** — Detailed format specifications for every component type (commands, skills, agents, hooks, MCP, CONNECTORS.md)
          - **`references/example-plugins.md`** — Three complete example plugin structures at different complexity levels
    - path: /knowledge-work-plugins/skills/create-cowork-plugin/references/component-schemas.md
      text: |
          # Component Schemas

          Detailed format specifications for every plugin component type. Reference this when implementing components in Phase 4.

          ## Commands

          **Location**: `commands/command-name.md`
          **Format**: Markdown with optional YAML frontmatter

          ### Frontmatter Fields

          | Field | Required | Type | Description |
          |-------|----------|------|-------------|
          | `description` | No | String | Brief description shown in `/help` (under 60 chars) |
          | `allowed-tools` | No | String or Array | Tools the command can use |
          | `model` | No | String | Model override: `sonnet`, `opus`, `haiku` |
          | `argument-hint` | No | String | Documents expected arguments for autocomplete |

          ### Example Command

          ```markdown
          ---
          description: Review code for security issues
          allowed-tools: Read, Grep, Bash(git:*)
          argument-hint: [file-path]
          ---

          Review @$1 for security vulnerabilities including:
          - SQL injection
          - XSS attacks
          - Authentication bypass
          - Insecure data handling

          Provide specific line numbers, severity ratings, and remediation suggestions.
          ```

          ### Key Rules

          - **Commands are instructions FOR Claude**, not messages for the user. Write them as directives.
          - `$ARGUMENTS` captures all arguments as a single string; `$1`, `$2`, `$3` capture positional arguments.
          - `@path` syntax includes file contents in the command context.
          - `!` backtick syntax executes bash inline for dynamic context (e.g., `` !`git diff --name-only` ``).
          - Use `${CLAUDE_PLUGIN_ROOT}` to reference plugin files portably.

          ### allowed-tools Patterns

          ```yaml
          # Specific tools
          allowed-tools: Read, Write, Edit, Bash(git:*)

          # Bash with specific commands only
          allowed-tools: Bash(npm:*), Read

          # MCP tools (specific)
          allowed-tools: ["mcp__plugin_name_server__tool_name"]
          ```

          ## Skills

          **Location**: `skills/skill-name/SKILL.md`
          **Format**: Markdown with YAML frontmatter

          ### Frontmatter Fields

          | Field | Required | Type | Description |
          |-------|----------|------|-------------|
          | `name` | Yes | String | Skill identifier |
          | `description` | Yes | String | Third-person description with trigger phrases |
          | `version` | No | String | Semver version |

          ### Example Skill

          ```yaml
          ---
          name: api-design
          description: >
            This skill should be used when the user asks to "design an API",
            "create API endpoints", "review API structure", or needs guidance
            on REST API best practices, endpoint naming, or request/response design.
          version: 0.1.0
          ---
          ```

          ### Writing Style Rules

          - **Frontmatter description**: Third-person ("This skill should be used when..."), with specific trigger phrases in quotes.
          - **Body**: Imperative/infinitive form ("Parse the config file," not "You should parse the config file").
          - **Length**: Keep SKILL.md body under 3,000 words (ideally 1,500-2,000). Move detailed content to `references/`.

          ### Skill Directory Structure

          ```
          skill-name/
          ├── SKILL.md              # Core knowledge (required)
          ├── references/           # Detailed docs loaded on demand
          │   ├── patterns.md
          │   └── advanced.md
          ├── examples/             # Working code examples
          │   └── sample-config.json
          └── scripts/              # Utility scripts
              └── validate.sh
          ```

          ### Progressive Disclosure Levels

          1. **Metadata** (always in context): name + description (~100 words)
          2. **SKILL.md body** (when skill triggers): core knowledge (<5k words)
          3. **Bundled resources** (as needed): references, examples, scripts (unlimited)

          ## Agents

          **Location**: `agents/agent-name.md`
          **Format**: Markdown with YAML frontmatter

          ### Frontmatter Fields

          | Field | Required | Type | Description |
          |-------|----------|------|-------------|
          | `name` | Yes | String | Lowercase, hyphens, 3-50 chars |
          | `description` | Yes | String | Triggering conditions with `<example>` blocks |
          | `model` | Yes | String | `inherit`, `sonnet`, `opus`, or `haiku` |
          | `color` | Yes | String | `blue`, `cyan`, `green`, `yellow`, `magenta`, `red` |
          | `tools` | No | Array | Restrict to specific tools |

          ### Example Agent

          ```markdown
          ---
          name: code-reviewer
          description: Use this agent when the user asks for a thorough code review or wants detailed analysis of code quality, security, and best practices.

          <example>
          Context: User has just written a new module
          user: "Can you do a deep review of this code?"
          assistant: "I'll use the code-reviewer agent to provide a thorough analysis."
          <commentary>
          User explicitly requested a detailed review, which matches this agent's specialty.
          </commentary>
          </example>

          <example>
          Context: User is about to merge a PR
          user: "Review this before I merge"
          assistant: "Let me run a comprehensive review using the code-reviewer agent."
          <commentary>
          Pre-merge review benefits from the agent's structured analysis process.
          </commentary>
          </example>

          model: inherit
          color: blue
          tools: ["Read", "Grep", "Glob"]
          ---

          You are a code review specialist focused on identifying issues across security, performance, maintainability, and correctness.

          **Your Core Responsibilities:**
          1. Analyze code structure and organization
          2. Identify security vulnerabilities
          3. Flag performance concerns
          4. Check adherence to best practices

          **Analysis Process:**
          1. Read all files in scope
          2. Identify patterns and anti-patterns
          3. Categorize findings by severity
          4. Provide specific remediation suggestions

          **Output Format:**
          Present findings grouped by severity (Critical, Warning, Info) with:
          - File path and line number
          - Description of the issue
          - Suggested fix
          ```

          ### Agent Naming Rules

          - 3-50 characters
          - Lowercase letters, numbers, hyphens only
          - Must start and end with alphanumeric
          - No underscores, spaces, or special characters

          ### Color Guidelines

          - Blue/Cyan: Analysis, review
          - Green: Success-oriented tasks
          - Yellow: Caution, validation
          - Red: Critical, security
          - Magenta: Creative, generation

          ## Hooks

          **Location**: `hooks/hooks.json`
          **Format**: JSON

          ### Available Events

          | Event | When it fires |
          |-------|--------------|
          | `PreToolUse` | Before a tool call executes |
          | `PostToolUse` | After a tool call completes |
          | `Stop` | When Claude finishes a response |
          | `SubagentStop` | When a subagent finishes |
          | `SessionStart` | When a session begins |
          | `SessionEnd` | When a session ends |
          | `UserPromptSubmit` | When the user sends a message |
          | `PreCompact` | Before context compaction |
          | `Notification` | When a notification fires |

          ### Hook Types

          **Prompt-based** (recommended for complex logic):
          ```json
          {
            "type": "prompt",
            "prompt": "Evaluate whether this file write follows project conventions: $TOOL_INPUT",
            "timeout": 30
          }
          ```
          Supported events: Stop, SubagentStop, UserPromptSubmit, PreToolUse.

          **Command-based** (deterministic checks):
          ```json
          {
            "type": "command",
            "command": "bash ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate.sh",
            "timeout": 60
          }
          ```

          ### Example hooks.json

          ```json
          {
            "PreToolUse": [
              {
                "matcher": "Write|Edit",
                "hooks": [
                  {
                    "type": "prompt",
                    "prompt": "Check that this file write follows project coding standards. If it violates standards, explain why and block.",
                    "timeout": 30
                  }
                ]
              }
            ],
            "SessionStart": [
              {
                "matcher": "",
                "hooks": [
                  {
                    "type": "command",
                    "command": "cat ${CLAUDE_PLUGIN_ROOT}/context/project-context.md",
                    "timeout": 10
                  }
                ]
              }
            ]
          }
          ```

          ### Hook Output Format (Command Hooks)

          Command hooks return JSON to stdout:

          ```json
          {
            "decision": "block",
            "reason": "File write violates naming convention"
          }
          ```

          Decisions: `approve`, `block`, `ask_user` (ask for confirmation).

          ## MCP Servers

          **Location**: `.mcp.json` at plugin root
          **Format**: JSON

          ### Server Types

          **stdio** (local process):
          ```json
          {
            "mcpServers": {
              "my-server": {
                "command": "node",
                "args": ["${CLAUDE_PLUGIN_ROOT}/servers/server.js"],
                "env": {
                  "API_KEY": "${API_KEY}"
                }
              }
            }
          }
          ```

          **SSE** (hosted with OAuth):
          ```json
          {
            "mcpServers": {
              "asana": {
                "type": "sse",
                "url": "https://mcp.asana.com/sse"
              }
            }
          }
          ```

          **HTTP** (REST API):
          ```json
          {
            "mcpServers": {
              "api-service": {
                "type": "http",
                "url": "https://api.example.com/mcp",
                "headers": {
                  "Authorization": "Bearer ${API_TOKEN}"
                }
              }
            }
          }
          ```

          ### Server Type Selection Guide

          | Type | Best for | Auth method |
          |------|----------|-------------|
          | stdio | Local tools, custom servers | Environment variables |
          | SSE | Hosted cloud services | OAuth (automatic) |
          | HTTP | REST API backends | Token headers |

          ### Environment Variable Expansion

          All MCP configs support `${VAR_NAME}` substitution:
          - `${CLAUDE_PLUGIN_ROOT}` — plugin directory (always use for portability)
          - `${ANY_ENV_VAR}` — user environment variables

          Document all required environment variables in the plugin README.

          ## CONNECTORS.md

          **Location**: Plugin root
          **When to create**: When the plugin references external tools by category rather than specific product

          ### Format

          ```markdown
          # Connectors

          ## How tool references work

          Plugin files use `~~category` as a placeholder for whatever tool the user
          connects in that category. For example, `~~project tracker` might mean
          Asana, Linear, Jira, or any other project tracker with an MCP server.

          Plugins are tool-agnostic — they describe workflows in terms of categories
          rather than specific products.

          ## Connectors for this plugin

          | Category | Placeholder | Included servers | Other options |
          |----------|-------------|-----------------|---------------|
          | Chat | `~~chat` | Slack | Microsoft Teams, Discord |
          | Project tracker | `~~project tracker` | Linear | Asana, Jira, Monday |
          ```

          ### Using ~~ Placeholders

          In plugin files (commands, skills, agents), reference tools generically:

          ```markdown
          Check ~~project tracker for open tickets assigned to the user.
          Post a summary to ~~chat in the team channel.
          ```

          During customization (via the cowork-plugin-customizer skill), these get replaced with specific tool names.

          ## README.md

          Every plugin should include a README with:

          1. **Overview** — what the plugin does
          2. **Components** — list of commands, skills, agents, hooks, MCP servers
          3. **Setup** — any required environment variables or configuration
          4. **Usage** — how to use each command or trigger each skill
          5. **Customization** — if CONNECTORS.md exists, mention it
    - path: /knowledge-work-plugins/skills/create-cowork-plugin/references/example-plugins.md
      text: |
          # Example Plugins

          Three complete plugin structures at different complexity levels. Use these as templates when implementing in Phase 4.

          ## Minimal Plugin: Single Command

          A simple plugin with one slash command and no other components.

          ### Structure

          ```
          meeting-notes/
          ├── .claude-plugin/
          │   └── plugin.json
          ├── commands/
          │   └── meeting-notes.md
          └── README.md
          ```

          ### plugin.json

          ```json
          {
            "name": "meeting-notes",
            "version": "0.1.0",
            "description": "Generate structured meeting notes from transcripts",
            "author": {
              "name": "User"
            }
          }
          ```

          ### commands/meeting-notes.md

          ```markdown
          ---
          description: Generate structured meeting notes from a transcript
          argument-hint: [transcript-file]
          allowed-tools: Read, Write
          ---

          Read the transcript at @$1 and generate structured meeting notes.

          Include these sections:
          1. **Attendees** — list all participants mentioned
          2. **Summary** — 2-3 sentence overview of the meeting
          3. **Key Decisions** — numbered list of decisions made
          4. **Action Items** — table with columns: Owner, Task, Due Date
          5. **Open Questions** — anything unresolved

          Write the notes to a new file named after the transcript with `-notes` appended.
          ```

          ---

          ## Standard Plugin: Skill + Commands + MCP

          A plugin that combines domain knowledge, user commands, and external service integration.

          ### Structure

          ```
          code-quality/
          ├── .claude-plugin/
          │   └── plugin.json
          ├── commands/
          │   ├── review.md
          │   └── fix-lint.md
          ├── skills/
          │   └── coding-standards/
          │       ├── SKILL.md
          │       └── references/
          │           └── style-rules.md
          ├── .mcp.json
          └── README.md
          ```

          ### plugin.json

          ```json
          {
            "name": "code-quality",
            "version": "0.1.0",
            "description": "Enforce coding standards with reviews, linting, and style guidance",
            "author": {
              "name": "User"
            }
          }
          ```

          ### commands/review.md

          ```markdown
          ---
          description: Review code changes for style and quality issues
          allowed-tools: Read, Grep, Bash(git:*)
          ---

          Get the list of changed files: !`git diff --name-only`

          For each changed file:
          1. Read the file
          2. Check against the coding-standards skill for style violations
          3. Identify potential bugs or anti-patterns
          4. Flag any security concerns

          Present a summary with:
          - File path
          - Issue severity (Error, Warning, Info)
          - Description and suggested fix
          ```

          ### commands/fix-lint.md

          ```markdown
          ---
          description: Auto-fix linting issues in changed files
          allowed-tools: Read, Write, Edit, Bash(npm:*)
          ---

          Run the linter: !`npm run lint -- --format json 2>&1`

          Parse the linter output and fix each issue:
          - For auto-fixable issues, apply the fix directly
          - For manual-fix issues, make the correction following project conventions
          - Skip issues that require architectural changes

          After all fixes, run the linter again to confirm clean output.
          ```

          ### skills/coding-standards/SKILL.md

          ```yaml
          ---
          name: coding-standards
          description: >
            This skill should be used when the user asks about "coding standards",
            "style guide", "naming conventions", "code formatting rules", or needs
            guidance on project-specific code quality expectations.
          version: 0.1.0
          ---
          ```

          ```markdown
          # Coding Standards

          Project coding standards and conventions for consistent, high-quality code.

          ## Core Rules

          - Use camelCase for variables and functions
          - Use PascalCase for classes and types
          - Prefer const over let; avoid var
          - Maximum line length: 100 characters
          - Use explicit return types on all exported functions

          ## Import Order

          1. External packages
          2. Internal packages (aliased with @/)
          3. Relative imports
          4. Type-only imports last

          ## Additional Resources

          - **`references/style-rules.md`** — complete style rules by language
          ```

          ### .mcp.json

          ```json
          {
            "mcpServers": {
              "github": {
                "type": "http",
                "url": "https://api.githubcopilot.com/mcp/"
              }
            }
          }
          ```

          ---

          ## Full-Featured Plugin: All Component Types

          A plugin using skills, commands, agents, hooks, and MCP integration with tool-agnostic connectors.

          ### Structure

          ```
          engineering-workflow/
          ├── .claude-plugin/
          │   └── plugin.json
          ├── commands/
          │   ├── standup-prep.md
          │   └── create-ticket.md
          ├── skills/
          │   └── team-processes/
          │       ├── SKILL.md
          │       └── references/
          │           └── workflow-guide.md
          ├── agents/
          │   └── ticket-analyzer.md
          ├── hooks/
          │   └── hooks.json
          ├── .mcp.json
          ├── CONNECTORS.md
          └── README.md
          ```

          ### plugin.json

          ```json
          {
            "name": "engineering-workflow",
            "version": "0.1.0",
            "description": "Streamline engineering workflows: standup prep, ticket management, and code quality",
            "author": {
              "name": "User"
            },
            "keywords": ["engineering", "workflow", "tickets", "standup"]
          }
          ```

          ### agents/ticket-analyzer.md

          ```markdown
          ---
          name: ticket-analyzer
          description: Use this agent when the user needs to analyze tickets, triage incoming issues, or prioritize a backlog.

          <example>
          Context: User is preparing for sprint planning
          user: "Help me triage these new tickets"
          assistant: "I'll use the ticket-analyzer agent to review and categorize the tickets."
          <commentary>
          Ticket triage requires systematic analysis across multiple dimensions, making the agent appropriate.
          </commentary>
          </example>

          <example>
          Context: User has a large backlog
          user: "Prioritize my backlog for next sprint"
          assistant: "Let me analyze the backlog using the ticket-analyzer agent to recommend priorities."
          <commentary>
          Backlog prioritization is a multi-step autonomous task well-suited for the agent.
          </commentary>
          </example>

          model: inherit
          color: cyan
          tools: ["Read", "Grep"]
          ---

          You are a ticket analysis specialist. Analyze tickets for priority, effort, and dependencies.

          **Your Core Responsibilities:**
          1. Categorize tickets by type (bug, feature, tech debt, improvement)
          2. Estimate relative effort (S, M, L, XL)
          3. Identify dependencies between tickets
          4. Recommend priority ordering

          **Analysis Process:**
          1. Read all ticket descriptions
          2. Categorize each by type
          3. Estimate effort based on scope
          4. Map dependencies
          5. Rank by impact-to-effort ratio

          **Output Format:**
          | Ticket | Type | Effort | Dependencies | Priority |
          |--------|------|--------|-------------|----------|
          | ...    | ...  | ...    | ...         | ...      |

          Followed by a brief rationale for the top 5 priorities.
          ```

          ### hooks/hooks.json

          ```json
          {
            "SessionStart": [
              {
                "matcher": "",
                "hooks": [
                  {
                    "type": "command",
                    "command": "echo '## Team Context\n\nSprint cycle: 2 weeks. Standup: daily at 9:30 AM. Use ~~project tracker for ticket management.'",
                    "timeout": 5
                  }
                ]
              }
            ]
          }
          ```

          ### CONNECTORS.md

          ```markdown
          # Connectors

          ## How tool references work

          Plugin files use `~~category` as a placeholder for whatever tool the user
          connects in that category. Plugins are tool-agnostic.

          ## Connectors for this plugin

          | Category | Placeholder | Included servers | Other options |
          |----------|-------------|-----------------|---------------|
          | Project tracker | `~~project tracker` | Linear | Asana, Jira, Monday |
          | Chat | `~~chat` | Slack | Microsoft Teams |
          | Source control | `~~source control` | GitHub | GitLab, Bitbucket |
          ```

          ### .mcp.json

          ```json
          {
            "mcpServers": {
              "linear": {
                "type": "sse",
                "url": "https://mcp.linear.app/sse"
              },
              "github": {
                "type": "http",
                "url": "https://api.githubcopilot.com/mcp/"
              },
              "slack": {
                "type": "http",
                "url": "https://slack.mcp.claude.com/mcp"
              }
            }
          }
          ```
  environment:
    - name: MESHAGENT_TOKEN
      token:  
        identity: claude-cowork-plugin-management
        api:
          livekit: {}
          queues:
            list: true
          messaging:
            broadcast: true
            list: true
            send: true
          database:
            list_tables: true
          sync: {}
          storage: {}
          containers:
            logs: true
            use_containers: true
          developer:
            logs: true
          agents:
            register_agent: true
            register_public_toolkit: true
            register_private_toolkit: true
            call: true
            use_agents: true
            use_tools: true
            allowed_toolkits: null
